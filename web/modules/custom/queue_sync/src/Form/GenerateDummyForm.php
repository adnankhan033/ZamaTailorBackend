<?php

namespace Drupal\queue_sync\Form;

use Drupal\Core\Form\FormBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;

class GenerateDummyForm extends FormBase {
  public function getFormId() {
    return 'queue_sync_generate_dummy_form';
  }

  public function buildForm(array $form, FormStateInterface $form_state) {
    $config = \Drupal::config('queue_sync.settings');
    $current_time = \Drupal::time()->getCurrentTime();
    $formatter = \Drupal::service('date.formatter');
    
    // Show current time
    $form['current_time'] = [
      '#type' => 'markup',
      '#markup' => '<div class="current-time-info">' .
        '<strong>' . $this->t('Current Time:') . '</strong> ' .
        $formatter->format($current_time, 'custom', 'Y-m-d H:i:s') .
        '</div>',
    ];
    
    $form['items'] = [
      '#type' => 'number',
      '#title' => $this->t('Number of dummy items'),
      '#description' => $this->t('Total number of items to create in this batch. Use large numbers (1000+) to test auto-chunking.'),
      '#default_value' => 5,
      '#min' => 1,
      '#max' => 100000,
      '#required' => TRUE,
      '#step' => 1,
    ];

    // Show capacity info and warnings for large datasets.
    $form['capacity_warning'] = [
      '#type' => 'markup',
      '#markup' => '<div class="capacity-warning messages messages--warning" style="display: none;">' .
        '<p><strong>' . $this->t('Large Dataset Warning:') . '</strong></p>' .
        '<p>' . $this->t('Creating batches with more than 1000 items will trigger automatic chunking.') . '</p>' .
        '<p>' . $this->t('The system will automatically split large datasets into multiple batches to prevent memory issues.') . '</p>' .
        '</div>',
    ];

    // Add JavaScript to show warning for large numbers.
    $form['#attached']['library'][] = 'queue_sync/settings';
    $form['#attached']['drupalSettings']['queueSync'] = [
      'largeDatasetThreshold' => 1000,
    ];
    
    $default_delay = $config->get('default_delay_minutes') ?? 1;
    $default_delay_seconds = $default_delay * 60;
    
    $form['delay_minutes'] = [
      '#type' => 'number',
      '#title' => $this->t('Delay (minutes) before processing'),
      '#description' => $this->t('Number of minutes to wait before this batch starts processing. Current default: @default', ['@default' => $this->formatMinutes($default_delay)]),
      '#default_value' => $default_delay,
      '#min' => 0,
      '#step' => 0.5,
      '#required' => TRUE,
      '#field_suffix' => $this->t('minutes'),
      '#attributes' => ['class' => ['delay-minutes']],
      '#suffix' => '<div class="delay-minutes-info">' .
        '<small><strong>' . $this->t('Info:') . '</strong> ' .
        '<span id="delay-minutes-display">' . $this->formatMinutes($default_delay) . '</span>' .
        '</small></div>' .
        '<div class="batch-preview">' . 
        '<strong>' . $this->t('Batch will run at:') . '</strong> ' .
        '<span id="run-time-preview">' . $formatter->format($current_time + $default_delay_seconds, 'custom', 'Y-m-d H:i:s') . '</span>' .
        '</div>',
    ];
    
    $form['submit'] = [
      '#type' => 'submit',
      '#value' => $this->t('Generate Batch'),
    ];
    
    $form['#attached']['library'][] = 'queue_sync/settings';
    
    // Add JavaScript to update preview
    $form['#attached']['drupalSettings']['queueSync'] = [
      'currentTime' => $current_time,
    ];
    
    return $form;
  }

  public function submitForm(array &$form, FormStateInterface $form_state) {
    $items = (int) $form_state->getValue('items');
    $delay = (int) $form_state->getValue('delay_minutes');
    $run_at = time() + ($delay * 60);
    $data = [];
    
    // For large datasets, generate user-like data for better testing.
    $is_large = $items > 1000;
    
    for ($i = 1; $i <= $items; $i++) {
      if ($is_large) {
        // Generate user-like data for large datasets.
        $data[] = [
          'uid' => $i,
          'username' => 'test_user_' . $i,
          'email' => 'test_user_' . $i . '@example.com',
          'status' => ($i % 2 == 0) ? 1 : 0,
          'created' => time() - ($i * 60),
          'sync_timestamp' => time(),
          'title' => 'Test User Record ' . $i,
          'body' => 'Generated test data for queue sync testing.',
        ];
      }
      else {
        // Simple data for small batches - always include uid for user sync compatibility.
        $data[] = [
          'uid' => $i,
          'username' => 'dummy_user_' . $i,
          'email' => 'dummy_' . $i . '@example.com',
          'status' => 1,
          'sync_timestamp' => time(),
          'title' => 'Dummy item ' . $i . ' at ' . date('Y-m-d H:i:s'),
          'body' => 'Generated by queue_sync.',
        ];
      }
      
      // Progress logging for very large datasets.
      if ($items > 10000 && $i % 5000 == 0) {
        \Drupal::logger('queue_sync')->info('Generating test data: @current of @total', [
          '@current' => $i,
          '@total' => $items,
        ]);
      }
    }
    
    // Create batch via service (with auto-chunking enabled).
    $runner = \Drupal::service('queue_sync.runner');
    $result = $runner->createBatch($data, $run_at, NULL, TRUE);
    
    // Handle both single batch and multiple batches (from auto-chunking).
    if (is_array($result)) {
      $this->messenger()->addMessage($this->t('Created large dataset with @count items split into @batches batches automatically.', [
        '@count' => $items,
        '@batches' => count($result),
      ]));
    }
    else {
      $this->messenger()->addMessage($this->t('Dummy batch created with @count items.', ['@count' => $items]));
    }
    
    $form_state->setRedirectUrl(Url::fromRoute('queue_sync.admin'));
  }
  
  /**
   * Format minutes value for display in info.
   */
  protected function formatMinutes($minutes) {
    if ($minutes == 0.5) {
      return $this->t('half minute (30 seconds)');
    }
    if ($minutes == 1) {
      return $this->t('1 minute');
    }
    if ($minutes < 1) {
      $seconds = $minutes * 60;
      return $this->t('@minutes minutes (@seconds seconds)', [
        '@minutes' => $minutes,
        '@seconds' => $seconds,
      ]);
    }
    if (floor($minutes) == $minutes) {
      return $this->t('@minutes minutes', ['@minutes' => $minutes]);
    }
    $seconds = round(($minutes - floor($minutes)) * 60);
    $whole_minutes = floor($minutes);
    if ($seconds == 30) {
      return $this->t('@minutes and a half minutes', ['@minutes' => $whole_minutes]);
    }
    return $this->t('@minutes minutes (@seconds seconds)', [
      '@minutes' => $whole_minutes,
      '@seconds' => $seconds,
    ]);
  }
}
